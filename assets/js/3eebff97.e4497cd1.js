"use strict";(self.webpackChunkvis_engine_docs=self.webpackChunkvis_engine_docs||[]).push([[3733],{9567:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=t(5250),a=t(3274);const o={id:"clouds",title:"Draw Cloud"},s=void 0,i={id:"playground/clouds",title:"Draw Cloud",description:"\u4e00\u4e2a\u7b80\u5355\u7684\u4e91\u4f53\u6e32\u67d3\u793a\u4f8b\uff0c\u8fd9\u91cc\u4e3b\u8981\u7528\u5230\u4e86\u5b9e\u4f8b\u5316\u6e32\u67d3\u6280\u672f\u3002",source:"@site/docs/playground/clouds.mdx",sourceDirName:"playground",slug:"/playground/clouds",permalink:"/vis-engine/docs/playground/clouds",draft:!1,unlisted:!1,editUrl:"https://github.com/sakitam-gis/vis-engine/edit/master/documents/docs/docs/playground/clouds.mdx",tags:[],version:"current",lastUpdatedBy:"sakitam-fdd",lastUpdatedAt:1711204280,formattedLastUpdatedAt:"Mar 23, 2024",frontMatter:{id:"clouds",title:"Draw Cloud"},sidebar:"docs",previous:{title:"Draw Box Volume Geometry",permalink:"/vis-engine/docs/playground/box-volume"},next:{title:"Draw GLTF",permalink:"/vis-engine/docs/playground/gltf"}},c={},l=[{value:"\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b",id:"\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b",level:3}];function d(n){const e={code:"code",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"\u4e00\u4e2a\u7b80\u5355\u7684\u4e91\u4f53\u6e32\u67d3\u793a\u4f8b\uff0c\u8fd9\u91cc\u4e3b\u8981\u7528\u5230\u4e86\u5b9e\u4f8b\u5316\u6e32\u67d3\u6280\u672f\u3002"}),"\n",(0,r.jsx)(e.h3,{id:"\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b",children:"\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsx",metastring:"live",live:!0,children:"function render(props) {\n  const drawVertex = `attribute vec2 uv;\n    attribute vec3 position;\n\n    attribute vec3 offset;\n    attribute vec3 random;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    varying vec2 vUv;\n\n    void rotate2d(inout vec2 v, float a){\n        mat2 m = mat2(cos(a), -sin(a), sin(a),  cos(a));\n        v = m * v;\n    }\n\n    void main() {\n        vUv = uv;\n\n        // copy position so that we can modify the instances\n        vec3 pos = position;\n\n        pos *= 0.5 + random.z * random.z * 1.5;\n\n        // rotate around y axis\n        rotate2d(pos.xz, random.y / 2.0);\n\n        // rotate around x axis just to add some extra variation\n        rotate2d(pos.zy, random.x * 3.14);\n\n        pos += offset;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n    }\n    `;\n\n  const drawFragment = `precision highp float;\n\n    uniform sampler2D texture;\n    uniform vec3 u_fogColor;\n    uniform float u_fogNear;\n    uniform float u_fogFar;\n\n    varying vec2 vUv;\n\n    void main() {\n      float depth = gl_FragCoord.z / gl_FragCoord.w;\n      float fogFactor = smoothstep(u_fogNear, u_fogFar, depth);\n      vec4 tex = texture2D(texture, vUv);\n      gl_FragColor = tex;\n      gl_FragColor.w *= pow(gl_FragCoord.z, 20.0);\n\t\t\tgl_FragColor = mix(gl_FragColor, vec4(u_fogColor, gl_FragColor.w), fogFactor);\n\t\t\t// gl_FragColor = vec4(0.5, 1.0, 0.5, 1.0);\n    }\n    `;\n\n  const refDom = useRef(null);\n  const meshRef = useRef(null);\n  const cameraRef = useRef(null);\n  const renderRef = useRef(null);\n  const mousePos = useRef([0, 0]);\n\n  const store = leva.useCreateStore();\n\n  const fov = 30;\n  const nearZ = 1;\n\n  const farZ = 3000;\n\n  const config = {\n    fov: {\n      value: fov,\n      min: -50,\n      max: 50,\n      step: 1,\n      onChange: (fov) => {\n        if (cameraRef.current) {\n          cameraRef.current.fov = fov;\n        }\n      },\n    },\n    nearZ: {\n      value: nearZ,\n      min: -50,\n      max: 50,\n      step: 0.1,\n      onChange: (nearZ) => {\n        if (cameraRef.current) {\n          cameraRef.current.near = nearZ;\n        }\n      },\n    },\n    farZ: {\n      value: farZ,\n      min: -500,\n      max: 500,\n      step: 1,\n      onChange: (farZ) => {\n        if (cameraRef.current) {\n          cameraRef.current.far = farZ;\n        }\n      },\n    },\n    cameraPosition: {\n      value: [0, 0, 15],\n      onChange: (p) => {\n        if (cameraRef.current) {\n          cameraRef.current.position.set(...p);\n        }\n      },\n    },\n    wireframe: {\n      value: false,\n      onChange: (p) => {\n        if (meshRef.current) {\n          meshRef.current.wireframe = p;\n        }\n      },\n    }\n  };\n\n  leva.useControls(config, {\n    store: store,\n  });\n\n  const image = useBaseUrl('/assets/cloud.png');\n\n  const init = () => {\n    const canvas = refDom.current;\n\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    const renderer = new Renderer(canvas, {\n      alpha: true,\n      antialias: true,\n      premultipliedAlpha: true,\n    });\n\n    renderer.state.setClearColor(new Color(0, 0, 0, 0));\n\n    renderRef.current = renderer;\n\n    const camera = new PerspectiveCamera(fov, canvas.width / canvas.height, nearZ, farZ);\n    cameraRef.current = camera;\n\n    function resize(target) {\n      const { width, height } = target.getBoundingClientRect();\n      renderer.setSize(width, height);\n      camera.aspect = width / height;\n    }\n\n    const scene = new Scene();\n\n    const planeGeometry = new Plane(renderer, {\n      width: 64,\n      height: 64,\n\n      widthSegments: 1,\n      heightSegments: 1,\n    });\n\n    const texture = new Texture(renderer, {\n      flipY: true,\n      width: 256,\n      height: 256,\n      minFilter: renderer.gl.LINEAR_MIPMAP_LINEAR\n    });\n\n    texture.fromSrc(image);\n\n    const program = new Program(renderer, {\n      vertexShader: drawVertex,\n      fragmentShader: drawFragment,\n      uniforms: {\n        texture: {\n          value: texture,\n        },\n        u_fogColor: {\n          value: [0.27058823529411763, 0.5176470588235295, 0.7058823529411765],\n        },\n        u_fogNear: {\n          value: -100,\n        },\n        u_fogFar: {\n          value: 3000,\n        },\n      },\n      cullFace: renderer.gl.BACK,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n      blendFunc: {\n        src: renderer.gl.SRC_ALPHA,\n        dst: renderer.gl.ONE_MINUS_SRC_ALPHA,\n        srcAlpha: renderer.gl.ONE,\n        dstAlpha: renderer.gl.ONE_MINUS_SRC_ALPHA,\n      },\n      blendEquation: {\n        modeRGB: renderer.gl.FUNC_ADD,\n        modeAlpha: renderer.gl.FUNC_ADD,\n      },\n    });\n\n    const num = 1000;\n    let offset = new Float32Array(num * 3);\n    let random = new Float32Array(num * 3);\n    for (let i = 0; i < num; i++) {\n      offset.set([Math.random() * 1000 - 500, -Math.random() * Math.random() * 200 - 15, i], i * 3);\n\n      // unique random values are always handy for instances.\n      // Here they will be used for rotation, scale and movement.\n      random.set([Math.random(), Math.random(), Math.random()], i * 3);\n    }\n\n    const geometry = new Geometry(renderer, {\n      position: planeGeometry.attributesData.position,\n      uv: planeGeometry.attributesData.uv,\n      normal: planeGeometry.attributesData.normal,\n      index: planeGeometry.attributesData.index,\n      offset: { divisor: 1, size: 3, data: offset },\n      random: { divisor: 1, size: 3, data: random },\n    });\n\n    const mesh = new Mesh(renderer, {\n      mode: renderer.gl.TRIANGLES,\n      geometry,\n      program,\n    });\n    mesh.setParent(scene);\n\n    const plane = new Mesh(renderer, {\n      geometry,\n      program,\n      wireframe: false,\n    });\n    plane.setParent(scene);\n\n    meshRef.current = plane;\n\n    const raf = new Raf((t) => {\n      const position = t * 30 % 1000;\n      const [mouseX, mouseY] = mousePos.current;\n\n      camera.position.x += (mouseX - camera.position.x) * 0.01;\n      camera.position.y += (-mouseY - camera.position.y) * 0.01;\n      camera.position.z = -position + 1000;\n\n      renderer.render({ scene, camera });\n    });\n\n    return {\n      canvas,\n      resize,\n    }\n  }\n\n  function onDocumentMouseMove(event) {\n    if (!refDom.current) return;\n    const windowHalfX = refDom.current.clientWidth / 2;\n    const windowHalfY = refDom.current.clientHeight / 2;\n    const mouseX = (event.clientX - windowHalfX) * 0.25;\n    const mouseY = (event.clientY - windowHalfY) * 0.15;\n    mousePos.current = [mouseX, mouseY];\n  }\n\n  useEffect(() => {\n    const { canvas, resize } = init();\n\n    observe(canvas, resize);\n\n    document.addEventListener('mousemove', onDocumentMouseMove, false);\n\n    const cv = document.createElement('canvas');\n    cv.width = 32;\n    cv.height = window.innerHeight;\n\n    const ctx = cv.getContext('2d');\n\n    const gradient = ctx.createLinearGradient(0, 0, 0, cv.height);\n    gradient.addColorStop(0, '#1e4877');\n    gradient.addColorStop(0.5, '#4584b4');\n\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, cv.width, cv.height);\n\n    canvas.style.background = 'url(' + cv.toDataURL('image/png') + ')';\n    canvas.style.backgroundSize = '32px 100%';\n\n    return () => {\n      unobserve(canvas, resize);\n      document.removeEventListener('mousemove', onDocumentMouseMove, false);\n    };\n  }, []);\n\n  return (\n    <div className=\"live-wrap\">\n      <div className=\"leva-wrap\">\n        <Leva\n          fill\n        ></Leva>\n        <LevaPanel collapsed store={store} fill></LevaPanel>\n      </div>\n      <canvas className=\"scene-canvas\" ref={refDom}></canvas>\n    </div>\n  );\n}\n"})})]})}function u(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},3274:(n,e,t)=>{t.d(e,{Z:()=>i,a:()=>s});var r=t(79);const a={},o=r.createContext(a);function s(n){const e=r.useContext(o);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),r.createElement(o.Provider,{value:e},n.children)}}}]);